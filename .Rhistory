theme_bw()
ggplot(data = plot_data, aes(x = within_factor, y = aggr_group, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = within_factor, y = values, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line(aes(linetype=within_factor) ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line(aes(linetype=within_factor) ) +
geom_point(aes(shape=within_factor))+
theme_bw()
# you can completely ignore the following function
# it serves merely to simulate example data
next_subject = function(sub_num) {
N = 150
sub_dat = data.frame(
subject_num = toString(sub_num),
condition = sample(c('fullvision', 'colorblind'), 1),
rt = rnorm(n = N, mean = 400, sd = 150),
response = sample(
c(rep('correct', 9), 'incorrect', 'tooslow'),
size = N,
replace = TRUE
),
color = sample(c('red', 'green'), size = N, replace = TRUE),
valence = sample(
c('positive', 'negative'),
size = N,
replace = TRUE
)
)
if (sub_dat$condition[1] == 'fullvision') {
green_neg = (sub_dat$color == 'green' &
sub_dat$valence == 'negative')
sub_dat$rt[green_neg] = sub_dat$rt[green_neg] + rnorm(n = length(sub_dat$rt[green_neg]),
mean = 43,
sd = 30)
sub_dat$response[green_neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[green_neg]),
replace = TRUE
)
red_pos = (sub_dat$color == 'red' &
sub_dat$valence == 'positive')
sub_dat$rt[red_pos] = sub_dat$rt[red_pos] + rnorm(n = length(sub_dat$rt[red_pos]),
mean = 37,
sd = 30)
sub_dat$response[red_pos] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[red_pos]),
replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
# install("neatStats", upgrade = "never", quick = TRUE)
library("neatStats")
# you can completely ignore the following function
# it serves merely to simulate example data
next_subject = function(sub_num) {
N = 150
sub_dat = data.frame(
subject_num = toString(sub_num),
condition = sample(c('fullvision', 'colorblind'), 1),
rt = rnorm(n = N, mean = 400, sd = 150),
response = sample(
c(rep('correct', 9), 'incorrect', 'tooslow'),
size = N,
replace = TRUE
),
color = sample(c('red', 'green'), size = N, replace = TRUE),
valence = sample(
c('positive', 'negative'),
size = N,
replace = TRUE
)
)
if (sub_dat$condition[1] == 'fullvision') {
green_neg = (sub_dat$color == 'green' &
sub_dat$valence == 'negative')
sub_dat$rt[green_neg] = sub_dat$rt[green_neg] + rnorm(n = length(sub_dat$rt[green_neg]),
mean = 43,
sd = 30)
sub_dat$response[green_neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[green_neg]),
replace = TRUE
)
red_pos = (sub_dat$color == 'red' &
sub_dat$valence == 'positive')
sub_dat$rt[red_pos] = sub_dat$rt[red_pos] + rnorm(n = length(sub_dat$rt[red_pos]),
mean = 37,
sd = 30)
sub_dat$response[red_pos] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[red_pos]),
replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
plot_neat(
data_per_subject = subjects_merged,
values = 'rt_green_negative, rt_green_positive, rt_red_negative, rt_red_positive',
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('er_green_negative', 'er_green_positive', 'er_red_negative', 'er_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
# now ANOVA on RTs for the main question: Color/Valence/Group interaction
anova_neat(
subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition',
bf_added = FALSE
)
anova_neat(
subjects_merged[subjects_merged$condition == 'colorblind',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
anova_neat(
subjects_merged[subjects_merged$condition == 'fullvision',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
# table to show basic data
table_neat(
list(
aggr_neat(subjects_merged, rt_green_negative),
aggr_neat(subjects_merged, rt_green_positive),
aggr_neat(subjects_merged, rt_red_negative),
aggr_neat(subjects_merged, rt_red_positive),
aggr_neat(subjects_merged, er_green_negative),
aggr_neat(subjects_merged, er_green_positive),
aggr_neat(subjects_merged, er_red_negative),
aggr_neat(subjects_merged, er_red_positive)
),
group_by = 'condition'
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
library(ggplot2)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), element_line = () )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
FALSE == "FALSE"
FALSE == "FALSES"
FALSE === "FALSE"
FALSE == "FALSE"
library(neatStats)
library(TOSTER)
library("neatStats")
setwd(path_neat("data"))
path_neat
file_names_app = list.files(pattern = "^CIT_Mobile_app.*txt$")
file_names_pc = list.files(pattern = "^CIT_Mobile_pc.*txt$")
if (length(file_names_app) != length(file_names_pc)) {
print(paste("length not OK! app", length(file_names_app), "vs. pc", length(file_names_pc)) )
stop("file number inconsistent")
}
subj_nums = c()
for (filee in file_names_app) {
subj_nums = c(subj_nums, strsplit(filee, "_")[[1]][4] )
}
subj_nums
subject_number = "2"
#f_name = "ECIT_.txt"
#subject_number = "2"
print(subject_number)
pc_l = list.files(pattern = paste("^CIT_Mobile_pc", subject_number, ".*txt$",sep="_")  )
subj_data_pc = read.table(  pc_l[1] , sep="\t", header=TRUE, fill=TRUE, quote="\"")
subj_data_pc$device_status = 0
pc_l = list.files(pattern = paste("^CIT_Mobile_pc", subject_number, ".*txt$",sep="_")  )
pc_l
subject_number
pc_l = list.files(pattern = paste("^CIT_Mobile_pc", subject_number, ".*txt$",sep="_")  )
pc_l
subject_number = "4"
#f_name = "ECIT_.txt"
#subject_number = "4"
print(subject_number)
pc_l = list.files(pattern = paste("^CIT_Mobile_pc", subject_number, ".*txt$",sep="_")  )
subj_data_pc = read.table(  pc_l[1] , sep="\t", header=TRUE, fill=TRUE, quote="\"")
subj_data_pc$device_status = 0
app_l = list.files(pattern = paste("^CIT_Mobile_app", subject_number, ".*txt$",sep="_")  )
subj_data_app = read.table(  app_l[1] , sep="\t", header=TRUE, fill=TRUE, quote="\"")
subj_data_app$device_status = 1
app_l
subj_data = merge( subj_data_pc, subj_data_app, all = T)
subj_data$stim_type <- as.character(subj_data$stim_type)
subj_data$stim_type[grepl('^irrelevant', subj_data$stim_type)] = "irrelevant"
subj_data$stim_type <- factor(subj_data$stim_type)
subj_itms_base = subj_data[which( subj_data$block_number %in% list(4,5) & subj_data$stim_type %in% list("probe", "irrelevant", "selfrefitem", "otherrefitem", "target") ),]
if (nrow(subj_itms_base) != 432) { # just double-check
print("number of rows:")
print(nrow(subj_itms_base))
stop("trial num incorrect")
}
all_unique_names = subj_itms_base[!duplicated(subj_itms_base$stimulus_shown), ]
if (nrow(all_unique_names) != 12) { # just double-check
print("number of unique names:")
print(nrow(all_unique_names))
stop("name problem")
}
all_unique_names
subj_itms_base$valid_trial = ifelse(subj_itms_base$incorrect == 0 & subj_itms_base$too_slow == 0 & subj_itms_base$rt_start >= 150, 1, 0)
subj_itms_base <- subj_itms_base[order(subj_itms_base$block_number, subj_itms_base$trial_number),]
subj_cond = as.character(subj_itms_base$device_status[1])
subj_lin_parts = list()
device_state = 0
subj_items = subj_itms_base[subj_itms_base$device_status==device_state,]
examples(aggr_neat)
example(aggr_neat)
source('C:/research/proj_neatstats/neatStats/R/aggr_neat.R', echo=TRUE)
library('devtools')
library("roxygen2")
setwd('C:/research/proj_neatstats/neatStats')
document()

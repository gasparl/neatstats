theme_bw() + scale_fill_manual(values = c('#666666', '#AAAAAA'))
to_plot
ggplot(data = plot_data, aes(x = aggr_group, y = values, fill = within_factor)) +
geom_line( ) +
theme_bw() + scale_fill_manual(values = c('#666666', '#AAAAAA'))
ggplot(data = plot_data, aes(x = aggr_group, y = values, fill = within_factor)) +
geom_line( ) +
theme_bw()
ggplot(data = plot_data, aes(x = within_factor, y = aggr_group)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = within_factor, y = aggr_group, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = within_factor, y = values, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=1)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line( ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line(aes(linetype=within_factor) ) +
geom_point()+
theme_bw()
ggplot(data = plot_data, aes(x = aggr_group, y = values, group=within_factor)) +
geom_line(aes(linetype=within_factor) ) +
geom_point(aes(shape=within_factor))+
theme_bw()
# you can completely ignore the following function
# it serves merely to simulate example data
next_subject = function(sub_num) {
N = 150
sub_dat = data.frame(
subject_num = toString(sub_num),
condition = sample(c('fullvision', 'colorblind'), 1),
rt = rnorm(n = N, mean = 400, sd = 150),
response = sample(
c(rep('correct', 9), 'incorrect', 'tooslow'),
size = N,
replace = TRUE
),
color = sample(c('red', 'green'), size = N, replace = TRUE),
valence = sample(
c('positive', 'negative'),
size = N,
replace = TRUE
)
)
if (sub_dat$condition[1] == 'fullvision') {
green_neg = (sub_dat$color == 'green' &
sub_dat$valence == 'negative')
sub_dat$rt[green_neg] = sub_dat$rt[green_neg] + rnorm(n = length(sub_dat$rt[green_neg]),
mean = 43,
sd = 30)
sub_dat$response[green_neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[green_neg]),
replace = TRUE
)
red_pos = (sub_dat$color == 'red' &
sub_dat$valence == 'positive')
sub_dat$rt[red_pos] = sub_dat$rt[red_pos] + rnorm(n = length(sub_dat$rt[red_pos]),
mean = 37,
sd = 30)
sub_dat$response[red_pos] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[red_pos]),
replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
# install("neatStats", upgrade = "never", quick = TRUE)
library("neatStats")
# you can completely ignore the following function
# it serves merely to simulate example data
next_subject = function(sub_num) {
N = 150
sub_dat = data.frame(
subject_num = toString(sub_num),
condition = sample(c('fullvision', 'colorblind'), 1),
rt = rnorm(n = N, mean = 400, sd = 150),
response = sample(
c(rep('correct', 9), 'incorrect', 'tooslow'),
size = N,
replace = TRUE
),
color = sample(c('red', 'green'), size = N, replace = TRUE),
valence = sample(
c('positive', 'negative'),
size = N,
replace = TRUE
)
)
if (sub_dat$condition[1] == 'fullvision') {
green_neg = (sub_dat$color == 'green' &
sub_dat$valence == 'negative')
sub_dat$rt[green_neg] = sub_dat$rt[green_neg] + rnorm(n = length(sub_dat$rt[green_neg]),
mean = 43,
sd = 30)
sub_dat$response[green_neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[green_neg]),
replace = TRUE
)
red_pos = (sub_dat$color == 'red' &
sub_dat$valence == 'positive')
sub_dat$rt[red_pos] = sub_dat$rt[red_pos] + rnorm(n = length(sub_dat$rt[red_pos]),
mean = 37,
sd = 30)
sub_dat$response[red_pos] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[red_pos]),
replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
plot_neat(
data_per_subject = subjects_merged,
values = 'rt_green_negative, rt_green_positive, rt_red_negative, rt_red_positive',
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('er_green_negative', 'er_green_positive', 'er_red_negative', 'er_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
# now ANOVA on RTs for the main question: Color/Valence/Group interaction
anova_neat(
subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition',
bf_added = FALSE
)
anova_neat(
subjects_merged[subjects_merged$condition == 'colorblind',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
anova_neat(
subjects_merged[subjects_merged$condition == 'fullvision',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
# table to show basic data
table_neat(
list(
aggr_neat(subjects_merged, rt_green_negative),
aggr_neat(subjects_merged, rt_green_positive),
aggr_neat(subjects_merged, rt_red_negative),
aggr_neat(subjects_merged, rt_red_positive),
aggr_neat(subjects_merged, er_green_negative),
aggr_neat(subjects_merged, er_green_positive),
aggr_neat(subjects_merged, er_red_negative),
aggr_neat(subjects_merged, er_red_positive)
),
group_by = 'condition'
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
library(ggplot2)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), element_line = () )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
FALSE == "FALSE"
FALSE == "FALSES"
FALSE === "FALSE"
FALSE == "FALSE"
library(neatStats)
library(TOSTER)
rnorm(n = 10000, mean = 0, sd = sd_sim)
control_SD_sim = liar_SD * 0.5077 + 7.1245
rnorm(n = 10000, mean = 0, sd = control_SD_sim)
liar_SD = 30.45
control_SD_sim = liar_SD * 0.5077 + 7.1245
rnorm(n = 10000, mean = 0, sd = control_SD_sim)
results = bayestestR::distribution_normal(n = 10000, mean = 0, sd = sd_sim)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n))
}
results = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
results
writeClipboard(control_data_sim)
control_data_sim = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
writeClipboard(control_data_sim)
writeClipboard(as.character(control_data_sim))
control_data_sim
control_SD_sim
control_data_sim = bayestestR::distribution_normal(n = 10000, mean = 0, sd = control_SD_sim)
control_data_sim
distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n))
}
distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n), mean, sd)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n), mean, sd)
}
control_data_sim = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
control_data_sim
writeClipboard(as.character(control_data_sim))
citation('psychReport')
ip = as.data.frame(installed.packages()[,c(1,3:4)])
ip = ip[is.na(ip$Priority),1:2,drop=FALSE]
ip
library(schoRsch)
setwd('C:/research/proj_neatstats/neatStats')
?anova_neat
library(neatStats)
?anova_neat
library('devtools')
library("roxygen2")
setwd('C:/research/proj_neatstats/neatStats')
document()
# devtools::check()
# devtools::build_manual()
# library("spelling")
# spelling::spell_check_package()
setwd('C:/research/proj_neatstats/')
#uninstall("neatStats")
install("neatStats", upgrade = "never")
devtools::check()
setwd('C:/research/proj_neatstats/neatStats')
document()
devtools::check()

replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
# install("neatStats", upgrade = "never", quick = TRUE)
library("neatStats")
# you can completely ignore the following function
# it serves merely to simulate example data
next_subject = function(sub_num) {
N = 150
sub_dat = data.frame(
subject_num = toString(sub_num),
condition = sample(c('fullvision', 'colorblind'), 1),
rt = rnorm(n = N, mean = 400, sd = 150),
response = sample(
c(rep('correct', 9), 'incorrect', 'tooslow'),
size = N,
replace = TRUE
),
color = sample(c('red', 'green'), size = N, replace = TRUE),
valence = sample(
c('positive', 'negative'),
size = N,
replace = TRUE
)
)
if (sub_dat$condition[1] == 'fullvision') {
green_neg = (sub_dat$color == 'green' &
sub_dat$valence == 'negative')
sub_dat$rt[green_neg] = sub_dat$rt[green_neg] + rnorm(n = length(sub_dat$rt[green_neg]),
mean = 43,
sd = 30)
sub_dat$response[green_neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[green_neg]),
replace = TRUE
)
red_pos = (sub_dat$color == 'red' &
sub_dat$valence == 'positive')
sub_dat$rt[red_pos] = sub_dat$rt[red_pos] + rnorm(n = length(sub_dat$rt[red_pos]),
mean = 37,
sd = 30)
sub_dat$response[red_pos] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[red_pos]),
replace = TRUE
)
}
neg = (sub_dat$valence == 'negative')
sub_dat$rt[neg] = sub_dat$rt[neg] + rnorm(n = length(sub_dat$rt[neg]),
mean = 40,
sd = 25)
sub_dat$response[neg] = sample(
c(rep('correct', 6), 'incorrect', 'tooslow'),
size = length(sub_dat$response[neg]),
replace = TRUE
)
return(sub_dat)
}
# the variable below simulates file names
filenames = 1:60
if (exists("subjects_merged")) {
rm(subjects_merged)
}
# now loop thru all data files
for (file_name in filenames) {
subject_data = next_subject(file_name)
# with real data, this would be e.g.:
# subject_data = read.table(file_name, stringsAsFactors=F, fill=T, header=T)
# print current file name - just to monitor the process
cat(file_name, ' ')
# now aggregate rt data per type
rts = aggr_neat(
subject_data,
rt,
group_by = 'color, valence',
method = mean,
prefix = 'rt'
)
# same with error rates
ers = aggr_neat(
subject_data,
response,
group_by = 'color, valence',
method = 'incorrect',
prefix = 'er',
filt = (response %in% c('correct', 'incorrect'))
)
# transpose to get the subject's data in one line
subject_line = table_neat(list(rts, ers), transpose = TRUE)
# add the subject_id and condition to the beginning
subject_line = data.frame(
subject_id = subject_data$subject_num[1],
condition = subject_data$condition[1],
subject_line
)
# merge aggregated subject data
if (!exists("subjects_merged")) {
# if doesn't yet exist, create first line
subjects_merged = subject_line
} else {
# if exists, add the next lines
subjects_merged = rbind(subjects_merged, subject_line)
# note: if some data may be discrepant for some participants (e.g., some
# participants are tested with blue and yellow colors too), you can use
# rbind.fill from the 'plyr' library to fill in missing data with NAs
}
}
plot_neat(
data_per_subject = subjects_merged,
values = 'rt_green_negative, rt_green_positive, rt_red_negative, rt_red_positive',
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
plot_neat(
data_per_subject = subjects_merged,
values = c('er_green_negative', 'er_green_positive', 'er_red_negative', 'er_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition'
)
# now ANOVA on RTs for the main question: Color/Valence/Group interaction
anova_neat(
subjects_merged,
values = c('rt_green_negative', 'rt_green_positive', 'rt_red_negative', 'rt_red_positive'),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
between_vars = 'condition',
bf_added = FALSE
)
anova_neat(
subjects_merged[subjects_merged$condition == 'colorblind',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
anova_neat(
subjects_merged[subjects_merged$condition == 'fullvision',],
values = c(
'rt_green_negative',
'rt_green_positive',
'rt_red_negative',
'rt_red_positive'
),
within_ids = list(
color = c('green', 'red'),
valence = c('positive', 'negative')
),
bf_added = T
)
# table to show basic data
table_neat(
list(
aggr_neat(subjects_merged, rt_green_negative),
aggr_neat(subjects_merged, rt_green_positive),
aggr_neat(subjects_merged, rt_red_negative),
aggr_neat(subjects_merged, rt_red_positive),
aggr_neat(subjects_merged, er_green_negative),
aggr_neat(subjects_merged, er_green_positive),
aggr_neat(subjects_merged, er_red_negative),
aggr_neat(subjects_merged, er_red_positive)
),
group_by = 'condition'
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
library(ggplot2)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
)
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank() )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), element_line = () )
p + theme_bw() + annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme( panel.border = element_blank(), axis.line = element_line() )
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
p <- ggplot(mtcars, aes(x = wt, y = mpg)) + geom_point()
p +  annotate(
geom = 'segment',
y = Inf,
yend = Inf,
x = -Inf,
xend = Inf
) + theme(panel.border = element_blank(), axis.line = element_line())
FALSE == "FALSE"
FALSE == "FALSES"
FALSE === "FALSE"
FALSE == "FALSE"
library(neatStats)
library(TOSTER)
rnorm(n = 10000, mean = 0, sd = sd_sim)
control_SD_sim = liar_SD * 0.5077 + 7.1245
rnorm(n = 10000, mean = 0, sd = control_SD_sim)
liar_SD = 30.45
control_SD_sim = liar_SD * 0.5077 + 7.1245
rnorm(n = 10000, mean = 0, sd = control_SD_sim)
results = bayestestR::distribution_normal(n = 10000, mean = 0, sd = sd_sim)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n))
}
results = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
results
writeClipboard(control_data_sim)
control_data_sim = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
writeClipboard(control_data_sim)
writeClipboard(as.character(control_data_sim))
control_data_sim
control_SD_sim
control_data_sim = bayestestR::distribution_normal(n = 10000, mean = 0, sd = control_SD_sim)
control_data_sim
distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n))
}
distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n), mean, sd)
distr_norm = function(n, mean = 0, sd = 1) {
stats::qnorm(seq(1 / n, 1 - 1 / n, length.out = n), mean, sd)
}
control_data_sim = distr_norm(n = 10000, mean = 0, sd = control_SD_sim)
control_data_sim
writeClipboard(as.character(control_data_sim))
citation('psychReport')
ip = as.data.frame(installed.packages()[,c(1,3:4)])
ip = ip[is.na(ip$Priority),1:2,drop=FALSE]
ip
library(schoRsch)
install.packages('scholar')
library(scholar)
get_publications("bg0BZ-QAAAAJ&hl")
xx = get_publications("bg0BZ-QAAAAJ&hl")
View(xx)
get_impactfactor("Quantitative Methods for Psychology")
get_impactfactor("The Quantitative Methods for Psychology")
get_impactfactor("Applied Psychology")
get_impactfactor("Methodology")
print "hi"
"hi"
5+8
pi = 3.141592654
radian = 24
pi*(radian**2)
str(2)
class()
class(2)
type(2)
typeof(2)
mode(2)
typeof("hi")
typeof(3)
typeof(3.3)
typeof(as.integer(3))
mode("hi")
mode(3)
### hi ####
print(1)
print(2)
list(1, "hi", "whatever")
my_list[2]
my_list = list( 14, "hi", "whatever")
my_list[2]
my_list[2][[1]]
my_list[[1]]
my_list[[2]]
my_list[[2:3]]
my_list[2:3]
?c
c('a', 2)
c(2, 'x')
c(2, list('x'))
c(14, 123, 6)
c(14, "some string")
6:23
22:1
2:6:1
seq(0, 10, by=2)
seq(4, 1, by=2)
seq(4, 1, by=-2)
rep(4, 5)
rep(12, 5)
rep("abc", 5)
?rep
rep(c(6,7), 5)
?seq
?c
help(":")
d = c(12,3,4,5,66)
d+1
d+2
plot(rnorm())
plot(rnorm(50))
density(rnorm(50))
plot(density(rnorm(50)))
density(rnorm(50))
plot(rnorm(50))
bayestestR::distribution_normal()
bayestestR::distribution_normal(50)
plot(bayestestR::distribution_normal(50))
plot()
?dump
sd(c(521, -1, 0, 0))
nchar("verständlich")
nchar(c("vertraut", "bekannt", "echt", "bedeutsam", "richtig", "wahrhaft", "sinnvoll", "tatsächlich", "gewusst", "geläufig", "verständlich"))
nchar("tatsächlich")
length(c("rützte", "girter", "zonsig", "fensch", "schwapf", "schlink", "kraubig", "behlsam", "hokisch", "noberal", "kriesam", "besärzt", "fosisch", "brirsam", "lathaft", "breuzig", "greibig", "glätisch", "weugvoll", "redengig", "gachligt", "verkemst", "pauflich", "heiglich", "wieflich", "schlinst", "plaucklos", "staumisch", "stürsisch", "kreibisch", "tintzlich", "brunenlos", "bänelich", "schriemrig", "klotselig", "gelörnsam"))
citation('plyar')
citation('plyr')
citation('Exact')
citation('ggpplot')
citation('ggplot')
citation('ggplot2')
library('devtools')
library("roxygen2")
setwd('C:/research/proj_neatstats/neatStats')
document()
devtools::check(args = '--run-donttest')
devtools::check()
devtools::build_manual()
load("C:/research/proj_neatstats/neatStats/.RData")
library('devtools')
library("roxygen2")
setwd('C:/research/proj_neatstats/neatStats')
document()
devtools::build_manual()
devtools::check()
?.onAttach
devtools::check()
devtools::build()
